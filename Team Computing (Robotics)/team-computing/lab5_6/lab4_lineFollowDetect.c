#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Reflected)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const float WHEEL_DIAMETER = 5.5;

long distToDegrees(long dist);
short measureTreshold();
long distToDegrees(long dist);
void turnWheel(long th);
void detectObstacle();
void onObstacleTurnLeft90();
void onObstacleTurnRight90();
void drive(long nMotorRatio, long dist, long motorPower);


long count = 0;
float avgSensorValue = 0.0;

task main()
{
		while(true)
		{
			//short treshold = measureTreshold();
			short treshold = 40;
			//displayBigTextLine(4, "%d", SensorValue[colorSensor]);
			turnWheel(treshold);
			detectObstacle();
		}
}

void turnWheel(long th)
{
	// Display sensor value on screen and debug stream
	displayBigTextLine(4, "%d", SensorValue[colorSensor]);
	writeDebugStreamLine("Value: %d", SensorValue[colorSensor]);

	/* If sensor value is less than treshold, set right motor speed to 0, and left motor speed to 20, if
		if is greater, set right motor speed to 20, and left motor speed to 0 */
	if(SensorValue[colorSensor] < th)
	{
		setMotorSpeed(rightMotor, 0);
		setMotorSpeed(leftMotor, 20);
	}
	else
	{
		setMotorSpeed(leftMotor, 0);
		setMotorSpeed(rightMotor, 20);
	}
}

long distToDegrees(long dist)
{
	return 2.0 * PI * WHEEL_DIAMETER * dist;
}

void detectObstacle()
{
	// Multisampling sonar sensor value
	count++;
	avgSensorValue += SensorValue(sonarSensor);
	if(count > 100)
	{
			avgSensorValue /= (float)count;
			displayCenteredBigTextLine(5, "%f", avgSensorValue);
			if(avgSensorValue < 8.0)
			{ // If distance to obstacle is less than 10cm

					// Print message on screen
					displayCenteredBigTextLine(3, "Obstacle detected\n");
					// Reset motors state
					resetMotorEncoder(rightMotor);
					resetMotorEncoder(leftMotor);

					onObstacleTurnLeft90();
					drive(0, 30, 30);

					onObstacleTurnRight90();
					drive(0, 40, 30);

					onObstacleTurnRight90();
					drive(0, 30, 30);

					onObstacleTurnLeft90();
			}
			// Reset multisampling variables
			count = 0;
			avgSensorValue = 0;
	}
}

void onObstacleTurnLeft90()
{ // Turn left 90 degrees
		resetMotorEncoder(rightMotor);
		resetMotorEncoder(leftMotor);
		setMotorTarget(rightMotor, 180, 20);
		setMotorTarget(leftMotor, 180, -20);
		waitUntilMotorStop(rightMotor);
		waitUntilMotorStop(leftMotor);
		sleep(50);
}

void onObstacleTurnRight90()
{ // Turn left 90 degrees
		resetMotorEncoder(rightMotor);
		resetMotorEncoder(leftMotor);
		setMotorTarget(rightMotor, 180, -20);
		setMotorTarget(leftMotor, 180, 20);
		waitUntilMotorStop(rightMotor);
		waitUntilMotorStop(leftMotor);
		sleep(50);
}



void drive(long nMotorRatio, long dist, long motorPower)
{ // Function that drives wheels on specified distance in centimeters. Function also takes nMotorRatio and motor power as arguments.
		float wheelDiameter = 5.5; // In cm
		float distanceInOneRotation = wheelDiameter * PI; //2*R*PI
		long rotations = dist / distanceInOneRotation; // How many full wheel rotations are in given distance
		setMotorSyncEncoder(leftMotor, rightMotor, nMotorRatio, 360 * rotations, motorPower);
		waitUntilMotorStop(leftMotor);
		waitUntilMotorStop(rightMotor);
}


short measureTreshold()
{
		// Measure treshold on start

		short treshold 	= 0;
		short lowValue 	= 0; // Dark color value
		short highValue = 0; // Bright color value
		short stage			= 0; // Stage(bright color measured? measure dark color)

		while(stage < 3)
		{
			switch(stage)
			{
				case 0:
					displayCenteredBigTextLine(4, "Place sensor on\n bright color");
					if(getButtonPress(buttonEnter))
					{
						highValue = SensorValue[colorSensor];
						sleep(500);
						stage = 1;
					}
					break;
				case 1:
					eraseDisplay();
					displayCenteredBigTextLine(4, "Place sensor on\n dark color");
					if(getButtonPress(buttonEnter))
					{
						lowValue = SensorValue[colorSensor];
						sleep(500);
						stage = 2;
					}
					break;
				case 2:
						eraseDisplay();
						treshold = (lowValue + highValue) / 2;
						displayCenteredBigTextLine(4, "Treshold = %d", treshold);
						sleep(3000);
						stage = 3;
						break;
			}
		}

		return treshold;
}
