#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Reflected)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const float WHEEL_DIAMETER = 5.5;

long distToDegrees(long dist);
long measureTreshold();
long distToDegrees(long dist);
void turnWheel(long th);

task main()
{
		while(true)
		{
			//short treshold = measureTreshold();
			long treshold = 40;
			turnWheel(treshold);
		}
}

void turnWheel(long th)
{
	// Display sensor value on screen and debug stream
	displayBigTextLine(4, "%d", SensorValue[colorSensor]);
	writeDebugStreamLine("Value: %d", SensorValue[colorSensor]);

	/* If sensor value is less than treshold, set right motor speed to 0, and left motor speed to 20, if
		if is greater, set right motor speed to 20, and left motor speed to 0 */
	if(SensorValue[colorSensor] < th)
	{
		setMotorSpeed(rightMotor, 0);
		setMotorSpeed(leftMotor, 20);
	}
	else
	{
		setMotorSpeed(leftMotor, 0);
		setMotorSpeed(rightMotor, 20);
	}
}

long distToDegrees(long dist)
{ // take distance as parametr and returns that distance in degrees that motor needs to turn
	return 2.0 * PI * WHEEL_DIAMETER * dist;
}

short measureTreshold()
{
		// Measure treshold on start

		short treshold 	= 0;
		short lowValue 	= 0; // Dark color value
		short highValue = 0; // Bright color value
		short stage			= 0; // Stage(bright color measured? measure dark color)

		while(stage < 3)
		{
			switch(stage)
			{
				case 0:
					displayCenteredBigTextLine(4, "Place sensor on\n bright color");
					if(getButtonPress(buttonEnter))
					{
						highValue = SensorValue[colorSensor];
						sleep(500);
						stage = 1;
					}
					break;
				case 1:
					eraseDisplay();
					displayCenteredBigTextLine(4, "Place sensor on\n dark color");
					if(getButtonPress(buttonEnter))
					{
						lowValue = SensorValue[colorSensor];
						sleep(500);
						stage = 2;
					}
					break;
				case 2:
						eraseDisplay();
						treshold = (lowValue + highValue) / 2;
						displayCenteredBigTextLine(4, "Treshold = %d", treshold);
						sleep(3000);
						stage = 3;
						break;
			}
		}

		return treshold;
}
