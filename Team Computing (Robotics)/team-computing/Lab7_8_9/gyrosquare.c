#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S4,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S2,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Program that allows the user to select a parimeter size for a square.


void drive(long nMotorRatio, long dist, long motorPower);
void turn();
void stop_moving();

task main()
{
	short menuPosition = 0;
	long distanceToTravel;
	bool buttonPressed = false;
	bool buttonEnterPressed = false;

	sleep(100);
	while (true)
	{
		// Clear display every frame
		eraseDisplay();
		// If buttonIp is pressed, increment menu position, else decrement menu position.
		// Check if menuPosition is not out of its bounds (0-3).
		if(getButtonPress(buttonUp) && !buttonPressed)
		{
			buttonPressed = true;
			menuPosition--;
			if(menuPosition < 0)
				menuPosition = 0;
		}
		if(getButtonPress(buttonDown) && !buttonPressed)
		{
			buttonPressed = true;
			menuPosition++;
			if(menuPosition > 3)
				menuPosition = 3;
		}

		// Display current menu position based on user input.
		switch(menuPosition)
		{
			case 0:
					displayCenteredBigTextLine(3, ">40cm<");
					displayCenteredBigTextLine(5, "80cm");
					displayCenteredBigTextLine(7, "100cm");
					displayCenteredBigTextLine(9, "120cm");
					distanceToTravel = 40.0/4;
					break;
			case 1:
					displayCenteredBigTextLine(3, "40cm");
					displayCenteredBigTextLine(5, ">80cm<");
					displayCenteredBigTextLine(7, "100cm");
					displayCenteredBigTextLine(9, "120cm");
					distanceToTravel = 80.0/4;
					break;
			case 2:
					displayCenteredBigTextLine(3, "40cm");
					displayCenteredBigTextLine(5, "80cm");
					displayCenteredBigTextLine(7, ">100cm<");
					displayCenteredBigTextLine(9, "120cm");
					distanceToTravel = 100.0/4;
					break;
			case 3:
					displayCenteredBigTextLine(3, "40cm");
					displayCenteredBigTextLine(5, "80cm");
					displayCenteredBigTextLine(7, "100cm");
					displayCenteredBigTextLine(9, ">120cm<");
					distanceToTravel = 120.0/4;
					break;
		}

		if(getGyroDegrees(gyroSensor)<0)
		{
			resetGyro(gyroSensor);
		}

		if(getGyroDegrees(gyroSensor)>0)
		{
			resetGyro(gyroSensor);
		}

		// If button enter pressed, start moving forward basing on menu option chosen by user.
		if(getButtonPress(buttonEnter) && !buttonEnterPressed)
		{
			buttonEnterPressed = true;

			if(getGyroDegrees(gyroSensor)==0)
			{
				drive(0, distanceToTravel, 50);
				turn();
				drive(0, distanceToTravel, 50);
				turn();
				drive(0, distanceToTravel, 50);
				turn();
				drive(0, distanceToTravel, 50);
				turn();
				stop_moving();
			}

		}

		// Check if buttons are released
		if(!getButtonPress(buttonDown) || !getButtonPress(buttonUp))
		{
			buttonPressed = false;
		}

		if(!getButtonPress(buttonEnter))
		{
			buttonEnterPressed = false;
		}
		// Wait 250 ms, this gives us 50 readings per second.
		sleep(250);
	}
}

void drive(long nMotorRatio, long dist, long motorPower)
{ // Function that drives wheels on specified distance in centimeters. Function also takes nMotorRatio and motor power as arguments.

		float wheelDiameter = 5.5; // In cm
		float distanceInOneRotation = wheelDiameter * PI; //2*R*PI
		float rotations = dist / distanceInOneRotation; // How many full wheel rotations are in given distance
		setMotorSyncEncoder(leftMotor, rightMotor, nMotorRatio, 360 * rotations, motorPower);
		waitUntilMotorStop(leftMotor);
		waitUntilMotorStop(rightMotor);

}
void turn()
{
		resetMotorEncoder(rightMotor);
		resetMotorEncoder(leftMotor);
		resetGyro(gyroSensor);
		sleep(200);
		while(fabs(getGyroDegrees(gyroSensor)) < 85)
		{
			setMotorSpeed(rightMotor, 10);
			setMotorSpeed(leftMotor, -10);
			//displayCenteredBigTextLine(5, "%d@", getGyroDegrees(gyroSensor));
		}
		setMotorSpeed(rightMotor, 0);
		setMotorSpeed(leftMotor, 0);
}

void stop_moving()
{
		setMotorSpeed(rightMotor, 0);  //Set the rightMotor (motor6) to half power (50)
		setMotorSpeed(leftMotor, 0); // Set the leftMotor to zero
		sleep(750);
}
