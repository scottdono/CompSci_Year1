#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void moveForward(int speed);
void detectObstacle();
void onObstacleTurnLeft90();
void displayDistance();
void drive(long nMotorRatio, long dist, long motorPower);

int detectObstacleCounter = 0;
int count = 0;
float avgSensorValue = 0.0;

task main()
{
	bool EXIT = false;

	while(!EXIT)
	{
		displayDistance();
		moveForward(35); // Move forward with 35 speed
		detectObstacle(); // Detect any obstacle
		if(detectObstacleCounter > 2)
		{ // If function detectObstacle was called more than 2 times, set EXIT to true which will exit main loop.
			drive(0, 30, 50); // Drive forward 30cm
			EXIT = true;
		}
	}
}

void moveForward(int speed)
{
	setMotorSpeed(rightMotor, speed);
	setMotorSpeed(leftMotor, speed);
}

void detectObstacle()
{
	// Multisampling sonar sensor value
	count++;
	avgSensorValue += SensorValue(sonarSensor);
	if(count > 100)
	{
			avgSensorValue /= (float)count;
			displayCenteredBigTextLine(5, "%f", avgSensorValue);
			if((avgSensorValue > 10.0 || SensorValue(touchSensor) == 1.0) && detectObstacleCounter < 3)
			{ // If distance to obstacle is less than 10cm or touch sensor is pressed or that function was called less than 2 times

					// Print message on screen
					displayCenteredBigTextLine(3, "Obstacle detected\n");
					// Reset motors state
					resetMotorEncoder(rightMotor);
					resetMotorEncoder(leftMotor);

					int randomSpeed = random(50) + 25;
					// move backward at -30 speed
					setMotorTarget(rightMotor, 360, randomSpeed * -1);
					setMotorTarget(leftMotor, 360, randomSpeed * -1);
					// Wait until motors stops
					waitUntilMotorStop(rightMotor);
					waitUntilMotorStop(leftMotor);
					// Turn 90 degrees left
					onObstacleTurnLeft90();
					//  Increment variable that counts how many times any sensor detected obstacle
					detectObstacleCounter++;
			}
			// Reset multisampling variables
			count = 0;
			avgSensorValue = 0;
	}
}

void onObstacleTurnLeft90()
{ // Turn left 90 degrees
		resetMotorEncoder(rightMotor);
		resetMotorEncoder(leftMotor);
		setMotorTarget(rightMotor, 180, 20);
		setMotorTarget(leftMotor, 180, -20);
		waitUntilMotorStop(rightMotor);
		waitUntilMotorStop(leftMotor);
		sleep(50);
}

void displayDistance()
{	// Display current distance to any obstacle
		eraseDisplay();
		displayCenteredBigTextLine(1, "%3d cm", SensorValue(sonarSensor));
}

void drive(long nMotorRatio, long dist, long motorPower)
{ // Function that drives wheels on specified distance in centimeters. Function also takes nMotorRatio and motor power as arguments.
		float wheelDiameter = 5.5; // In cm
		float distanceInOneRotation = wheelDiameter * PI; //2*R*PI
		long rotations = dist / distanceInOneRotation; // How many full wheel rotations are in given distance
		setMotorSyncEncoder(leftMotor, rightMotor, nMotorRatio, 360 * rotations, motorPower);
		waitUntilMotorStop(leftMotor);
		waitUntilMotorStop(rightMotor);
}
